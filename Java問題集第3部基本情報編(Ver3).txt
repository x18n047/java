
Java問題集第3部・基本情報編


【課題301】Nenreix.java				一次元配列　年齢構成表と横棒グラフ（ヒストグラム）
【課題302】MojiHanten.java			一次元配列 (文字列の反転)
【課題303】MojiCount.java			出現文字数のカウント	比較演算子( ==, != )
【課題304】NibunTansaku.java			二分探索　
【課題305】SelectionSort.java			基本選択法でソート処理
【課題306】BubbleSort.java			基本交換法でソート処理
【課題307】InsertSort.java			基本挿入法でソート処理
【課題308】MergeSotrx.java			マージソート
【課題309】Convert10to16.java			10進数→16進数への変換
【課題310】Convert10toM.java			10進数→M進数への変換
【課題311】ArrayKaiten.java			文字の回転・反転
【課題312】ArrayBai.java			文字の拡大
【課題313】Test8_2x.java			1次元配列の受け渡し・最大値、最小値、平均値、最頻値を求める。

【課題314】arrayKaiten4.java			猫の回転
【課題315】spredsheet2.java			スプレッドシートを作成してみる。	


*************************************************
一次元配列　年齢構成表と横棒グラフ（ヒストグラム）
*************************************************
【課題301】Nenreix.java
0歳から69歳までの年齢データを乱数にて20回発生させ、そのデータを1件ずつ読みながら
年齢構成テーブルに格納してゆき、その年代の人数を横棒グラフで表示する。

【ヒント】→年齢と添字をある計算で対応させると年齢の範囲を判定する必要がない。

年齢構成テーブルはint nenrei[7]で定義し要素として人数を格納する。
nenrei[0]は 0代の人数を格納する。(0,1,..9歳)
nenrei[1]は10代の人数を格納する。(10,11,....19歳)
nenrei[2]は20代の人数を格納する。
nenrei[3]は30代の人数を格納する。
nenrei[4]は40代の人数を格納する。
nenrei[5]は50代の人数を格納する。
nenrei[6]は60代の人数を格納する。

<実行結果例>
（実行例１）
乱数で生成したデータ : 30,59,2,25,35,61,57,18,17,36,3,5,14,11,45,12,63,52,51,50,

nenrei[0] = 3
nenrei[1] = 5
nenrei[2] = 1
nenrei[3] = 3
nenrei[4] = 1
nenrei[5] = 5
nenrei[6] = 2

0代     : 3人   ***
10代    : 5人   *****
20代    : 1人   *
30代    : 3人   ***
40代    : 1人   *
50代    : 5人   *****
60代    : 2人   **


******************************************
一次元配列 (文字列の反転)
******************************************
【課題302】MojiHanten.java
一次元配列内の文字を反転させるプログラムを作成しなさい。
【ヒント】→以下のソースプログラムを参考にしなさい。
		char[] str = {'f','u','n','a','b','a','s','h','i'};
		for(i = 0, j = str.length - 1; i < str.length / 2; 省略, 省略){	
	
<実行結果>
（実行例１）
文字反転前の配列str : f u n a b a s h i
文字反転後の配列str : i h s a b a n u f


**************************************************************
出現文字数のカウント	比較演算子( ==, != )
**************************************************************
【課題303】MojiCount.java
一次元配列dataの値にどのアルファベットが何文字出現するかをカウントして
それを表示するプログラムを作成する。
【ヒント】→dataの要素を順に読み、配列alphaの内容と合致していれば、その添え字を
		利用して配列countの該当する要素を１UPする。
		
		以下のソースプログラムを参考にしなさい。

	char[] alpha = {'a','b','c','d','e','f','g','h','i','j','k','l','m',
				'n','o','p','q','r','s','t','u','v','w','x','y','z'};
	/*文字数カウントの対象となる配列data*/
	/*内容は博多華丸() */
	char[] data = {'h','a','k','a','t','a','h','a','n','a','m','a','r','u'};
	int[] count = new int[26];	/*alphabet分の要素を確保する

	count[j]++;
	
<処理結果>
（実行例）
data = h a k a t a h a n a m a r u
文字aは 6個出現しました。
文字hは 2個出現しました。
文字kは 1個出現しました。
文字mは 1個出現しました。
文字nは 1個出現しました。
文字rは 1個出現しました。
文字tは 1個出現しました。
文字uは 1個出現しました。


********************************************************************************
二分探索　
********************************************************************************
【課題304】NibunTansaku.java
配列tblより二分探索を行い、探索データが添え字の何番目にあるかを表示する。
ヒント→テキストP312を参照

		以下のソースプログラムを参考にしなさい。
		int[] tbl = {3,4,7,8,10,12,15,19,20};	/*探索する対象となる配列tbl*/
					/*必ず昇順で整列されていること*/
		int i;			/*添え字、カウンタ*/
		int data;		/*二分探索するデータ*/
		int idx;		/*探索できた際の配列tblの添え字*/
		int low;		/*探索範囲の下限の添え字*/
		int high;		/*探索範囲の上限の添え字*/
		int mid;		/*探索範囲の中央の添え字*/	
		boolean okflg = false;	/*探索に成功したらtrueを代入する*/
		省略	
		/*初期値の設定*/
		idx = 0;
		low = 0;
		high = tbl.length - 1;

		/*low>highになったりojflg== true(見つかった)になったら終了する。*/
		while( low <= high && okflg == false){
			mid = (low + high) / 2 ;	/*midはlowとhighの中/*	
		省略
<実行結果例>
（実行例１）
tbl = 3 4 7 8 10 12 15 19 20
探索する整数を入力してください > 3
low=0 high=8 mid=4
low=0 high=3 mid=1
low=0 high=0 mid=0
探索した整数3はtbl[0]に存在します。

（実行例２）
tbl = 3 4 7 8 10 12 15 19 20
探索する整数を入力してください > 8
low=0 high=8 mid=4
low=0 high=3 mid=1
low=2 high=3 mid=2
low=3 high=3 mid=3
探索した整数8はtbl[3]に存在します。

（実行例３）
tbl = 3 4 7 8 10 12 15 19 20
探索する整数を入力してください > 10
low=0 high=8 mid=4
探索した整数10はtbl[4]に存在します。

（実行例４）
tbl = 3 4 7 8 10 12 15 19 20
探索する整数を入力してください > 20
low=0 high=8 mid=4
low=5 high=8 mid=6
low=7 high=8 mid=7
low=8 high=8 mid=8
探索した整数20はtbl[8]に存在します。

（実行例５）
tbl = 3 4 7 8 10 12 15 19 20
探索する整数を入力してください > 30
low=0 high=8 mid=4
low=5 high=8 mid=6
low=7 high=8 mid=7
low=8 high=8 mid=8
low=9 high=8
探索した整数30はtbl[ ]に存在しませんでした。


******************************************
基本選択法でソート処理
******************************************
【課題305】SelectionSort.java
基本選択法でSort処理(昇順)を行うプログラムを作成しなさい。
【ヒント】→テキストP317を参照すること。
　　　　	配列の先頭から照準に確定させていく。

<実行結果>
配列inputの内容 :52 64 33 76 21 18 49 43
msg: 値を入替える毎に配列の内容を表示します。
入替後:33 64 52 76 21 18 49 43
入替後:21 64 52 76 33 18 49 43
入替後:18 64 52 76 33 21 49 43
入替後:18 52 64 76 33 21 49 43
入替後:18 33 64 76 52 21 49 43
入替後:18 21 64 76 52 33 49 43
入替後:18 21 52 76 64 33 49 43
入替後:18 21 33 76 64 52 49 43
入替後:18 21 33 64 76 52 49 43
入替後:18 21 33 52 76 64 49 43
入替後:18 21 33 49 76 64 52 43
入替後:18 21 33 43 76 64 52 49
入替後:18 21 33 43 64 76 52 49
入替後:18 21 33 43 52 76 64 49
入替後:18 21 33 43 49 76 64 52
入替後:18 21 33 43 49 64 76 52
入替後:18 21 33 43 49 52 76 64
入替後:18 21 33 43 49 52 64 76
配列outputの内容:18 21 33 43 49 52 64 76



******************************************
基本交換法でソート処理
******************************************
【課題306】BubbleSort.java
基本交換法でSort処理(昇順)を行うプログラムを作成しなさい。
ヒント→テキストP321を参照

<実行結果>
（実行例１）
配列inputの内容 :52 64 33 76 21 18 49 43
値を入替える毎に配列の内容を表示します。
入替後:52 33 64 76 21 18 49 43
入替後:52 33 64 21 76 18 49 43
入替後:52 33 64 21 18 76 49 43
入替後:52 33 64 21 18 49 76 43
入替後:52 33 64 21 18 49 43 76
入替後:33 52 64 21 18 49 43 76
入替後:33 52 21 64 18 49 43 76
入替後:33 52 21 18 64 49 43 76
入替後:33 52 21 18 49 64 43 76
入替後:33 52 21 18 49 43 64 76
入替後:33 21 52 18 49 43 64 76
入替後:33 21 18 52 49 43 64 76
入替後:33 21 18 49 52 43 64 76
入替後:33 21 18 49 43 52 64 76
入替後:21 33 18 49 43 52 64 76
入替後:21 18 33 49 43 52 64 76
入替後:21 18 33 43 49 52 64 76
入替後:18 21 33 43 49 52 64 76
配列outputの内容:18 21 33 43 49 52 64 76


******************************************
基本挿入法でソート処理
******************************************
【課題307】InsertSort.java
基本挿入法でSort処理(昇順)を行うプログラムを作成しなさい。
ヒント→テキストP319を参照のこと。

<処理結果>
input :52 64 33 76 21 18 49 43
msg: 値を入替える毎に配列の内容を表示します。
入替後:33 52 64 76 21 18 49 43
入替後:21 33 52 64 76 18 49 43
入替後:18 21 33 52 64 76 49 43
入替後:18 21 33 49 52 64 76 43
入替後:18 21 33 43 49 52 64 76
output:18 21 33 43 49 52 64 76


******************************************
マージソート
******************************************
【課題308】MergeSortx.java
マージソートを行い、その結果を表示するプログラムを作成しなさい。
【ヒント】→以下のソースプログラムを参照
		Merge mg = new Merge();
		mg.mergeSort(array1,array2,array3);					//mergeSort実行
	
		class Merge{
			void mergeSort( int[] ary1, int[] ary2, int[] ary3){
		
<実行結果>
msg: array1[] と array2[] をマージソートし、array3[]に格納する
array1[] = 1 3 5 7 9 11 13 15 17 19 25 26 28 29
array2[] = 2 4 6 8 10 12 14 16 18 20 21 22 23 24 27 30
array3[] = 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26
27 28 29 30


********************************************************************************
10進数→16進数への変換
********************************************************************************
【課題309】Convert10to16.java
10進数の値を16進数に変換して表示するプログラムを作成しなさい。
【ヒント】→以下のソースプログラムを参照
		char[] tbl16 = {'0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F'};
		/*入力された10進数の値を16進数に変換*/
		for( i = int10; i != 0; i = i / 16){
			str16 = tbl16[i%16] + str16;
		}
		/*配列str16の内容が変化していない場合は0が入力されたと判断する*/
		if( str16.equals("")){
			str16 = '0' + str16;
		}
		
<処理結果>
（実行例１）
10進数の整数を入力してください。> 0
0(10) => 0(16)

（実行例２）
10進数の整数を入力してください。> 1
1(10) => 1(16)

（実行例３）
10進数の整数を入力してください。> 15
15(10) => F(16)

（実行例４）
10進数の整数を入力してください。> 16
16(10) => 10(16)

（実行例５）
10進数の整数を入力してください。> 256
256(10) => 100(16)

（実行例６）
10進数の整数を入力してください。> 4096
4096(10) => 1000(16)


********************************************************************************
10進数→M進数への変換
********************************************************************************
【課題310】Convert10toM.java
10進数の値をM進数に変換して表示するプログラムを作成しなさい。
ヒント→convert10to16.javaを参照

<処理結果例>
（実行例１）
10進数の整数を入力して下さい。> 0
何進数に変換しますか？(Mは2進数から16進数) > 2
0(10) => 0(2)

（実行例２）
10進数の整数を入力して下さい。> 1
何進数に変換しますか？(Mは2進数から16進数) > 8
1(10) => 1(8)

（実行例３）
10進数の整数を入力して下さい。> 15
何進数に変換しますか？(Mは2進数から16進数) > 2
15(10) => 1111(2)

（実行例４）
10進数の整数を入力して下さい。> 16
何進数に変換しますか？(Mは2進数から16進数) > 8
16(10) => 20(8)

（実行例５）
10進数の整数を入力して下さい。> 256
何進数に変換しますか？(Mは2進数から16進数) > 2
256(10) => 100000000(2)

（実行例６）
10進数の整数を入力して下さい。> 255
何進数に変換しますか？(Mは2進数から16進数) > 2
255(10) => 11111111(2)

（実行例７）
10進数の整数を入力して下さい。> 4096
何進数に変換しますか？(Mは2進数から16進数) > 2
4096(10) => 1000000000000(2)

（実行例８）
10進数の整数を入力して下さい。> 15
何進数に変換しますか？(Mは2進数から16進数) > 16
15(10) => F(16)

（実行例９）
10進数の整数を入力して下さい。> 31
何進数に変換しますか？(Mは2進数から16進数) > 16
31(10) => 1F(16)





************************************************
文字の回転・反転
************************************************
【課題311】arrayKaiten.java
5行5列の二次元配列に置かれたFの字に対し①～⑤の処理を行うプログラムを作成する。
①９０度右回転、②９０度左回転、③１８０度右回転１８０度左回転、
④左右対称、⑤上下反転　
【ヒント】→ソースプログラムの一部を参照

		final int N = 5;								/*5行5列の配列*/
		char[][] in_array={{' ','*','*','*',' '},		/*処理前の配列*/
			　　　 	{' ','*',' ',' ',' '},
				{' ','*','*','*',' '},
				{' ','*',' ',' ',' '},
				{' ','*',' ',' ',' '}
				};	
	
		char[][] out_array={{' ',' ',' ',' ',' '},		/*実際に処理を行う配列*/
					省略
			  	{' ',' ',' ',' ',' '}
			 	};
	
		
		/*各回転処理を行う*/				 
		for( i = 0; i < N; i++){
			for( j = 0; j < N; j++){
				
				switch( syori ){
					case 1:				
						/*９０度右回転*/	
						out_array[j][N-1-i] = in_array[i][j];
						break;
						
					case 2:		
						/*９０度左回転*/	
						out_array[N-1-j][i] = in_array[i][j];
						break;
					
					case 3:	
						/* １８０度右回転 １８０度左回転*/
						/*処理を考えて記述しなさい。*/
						break;
					
					case 4:
						/* 左右対称 */
						/*処理を考えて記述しなさい。*/
						break;
						
					case 5:
						/* 上下反転 */
						/*処理を考えて記述しなさい。*/
						break;
					default:
						System.out.println("処理選択エラーです");
						System.exit(1);
				}
				
			}
		}

<実行結果>>
（実行例１）
Before array						//回転前
 ***
 *
 ***
 *
 *

９０度右回転:1						//メニュー
９０度左回転:2
１８０度右回転 １８０度左回転:3
左右対称:4
上下反転:5
処理を選んでください。(1-5) > 1		//処理選択

After array							//回転後

*****
  * *
  * *

（実行例２）
Before array
 ***
 *
 ***
 *
 *

９０度右回転:1
９０度左回転:2
１８０度右回転 １８０度左回転:3
左右対称:4
上下反転:5
処理を選んでください。(1-5) > 2

After array

* *
* *
*****

（実行例３）
Before array
 ***
 *
 ***
 *
 *

９０度右回転:1
９０度左回転:2
１８０度右回転 １８０度左回転:3
左右対称:4
上下反転:5
処理を選んでください。(1-5) > 3

After array
   *
   *
 ***
   *
 ***

（実行例４）
Before array
 ***
 *
 ***
 *
 *

９０度右回転:1
９０度左回転:2
１８０度右回転 １８０度左回転:3
左右対称:4
上下反転:5
処理を選んでください。(1-5) > 4

After array
 ***
   *
 ***
   *
   *

（実行例５）
kouki>java arrayKaiten
Before array
 ***
 *
 ***
 *
 *

９０度右回転:1
９０度左回転:2
１８０度右回転 １８０度左回転:3
左右対称:4
上下反転:5
処理を選んでください。(1-5) > 5

After array
 *
 *
 ***
 *
 ***

（実行例６）
kouki>java arrayKaiten
Before array
 ***
 *
 ***
 *
 *

９０度右回転:1
９０度左回転:2
１８０度右回転 １８０度左回転:3
左右対称:4
上下反転:5
処理を選んでください。(1-5) > 0
処理選択エラーです


************************************************
文字の拡大
************************************************
【課題312】ArrayBai.java
5行5列の二次元配列に置かれたFの字に対し左上を基点として倍率指定処理を行うプログラムを作成しなさい。
ただし、倍率の指定は1倍から5倍までとする。
ヒント→二次元配列の左上を基点に考える。
		ソースプログラムの一部を参考にしなさい。
		final int N = 5;							/*5行5列の配列*/

		char in_array[][]={{' ','*','*','*',' '},				/*処理前の配列*/
			  		{' ','*',' ',' ',' '},
			 		{' ','*','*','*',' '},
			  		{' ','*',' ',' ',' '},
					{' ','*',' ',' ',' '}
				 };	

		/*5倍の領域の配列を確保*/
		char[][] out_array = new char[N*N][N*N];

<処理結果>
（実行例１）
Before array

 ***
 *
 ***
 *
 *

何倍にするか指定してください。(1-5) > 4
After array

    ************
    ************
    ************
    ************
    ****
    ****
    ****
    ****
    ************
    ************
    ************
    ************
    ****
    ****
    ****
    ****
    ****
    ****
    ****
    ****


************************************************
１次元配列の受け渡し
************************************************
【課題313】Test8_2x.java			1次元配列の受け渡し
1次元配列を渡し、その中に格納された値の最大値、最小値、平均値、最頻値（最も多く出現する数）を求める。
ヒント→テキストP239　P240を参照
ヒント→最頻値の求め方が少し難しい。
	arrayTensu[]の値を別の配列arraymode[]にコピーし、arraymode[]をバブルソート等を利用して
	昇順に並び替え、先頭からデータを読む。現在の値と次の値を比較しながら、どの値が一番
	多く出現しているかをカウントしながら選んでいく。（他の方法があれば、それを実現してみること。）

ヒント→以下のソースプログラムを参照のこと
	public static void main(String[] args){
		int[] arrayTensu = {10,30,20,40,70,20,10,50,40,70,70,90};   

		Search sh = new Search();
		
		for(int i = 0; i < arrayTensu.length; i++){
			System.out.print("配列["+ i + "]=" + arrayTensu[i] + "\t");
			省略
			}
		}
		System.out.println();
		//テスト結果の表示
		
		System.out.println("配列要素中の最小値　→　" + sh.minimum(arrayTensu));
		System.out.println("配列要素中の最大値　→　" + sh.maximum(arrayTensu));		
		System.out.println("配列要素中の平均値　→　" + sh.average(arrayTensu));
		System.out.println("配列要素中の最頻値　→　" + sh.mode(arrayTensu));
	}

	//最頻値の探索
	public int mode( int[] arrayData ){	
		int[] arraymode = new int[arrayData.length];
		int N = arrayData.length - 1;
		int work;
		
		//arrayData[]の値をarraymode[]に複写する
		
		//arraymode[]内をバブルソートにて昇順に整列
		for(int i = N; i > 0; i--){
			for(int j = 0; j < i; j++){
				if(arraymode[j] > arraymode[j + 1]){
					work = arraymode[j];
					arraymode[j] = arraymode[j + 1];
					arraymode[j + 1] = work;
					System.out.print("arraymode = ");
					for( int k = 0; k <= N; k++){
						System.out.print(arraymode[k] + " ");
					}
					System.out.println();
				}
			}
		}
		

		//arraymode[]を先頭から読み、最頻値を求める
		int max = 1;		//最頻値の最大出現個数
		int equal_count = 1;	//最頻値の出現個数
		int j = 0;		//最頻値の場所(添字）
		for(int i = 0; i < arraymode.length - 1; i++){
			
			if(arraymode[i] == arraymode[i+1]){
				equal_count++;
			省略
		}
		return arraymode[j];				//最頻値を返す
	}


/*
実行結果

配列[0]=10      配列[1]=30      配列[2]=20
配列[3]=40      配列[4]=70      配列[5]=20
配列[6]=10      配列[7]=50      配列[8]=40
配列[9]=70      配列[10]=70     配列[11]=90

配列要素中の最小値　→　10
配列要素中の最大値　→　90
配列要素中の平均値　→　43
arraymode = 10 20 30 40 70 20 10 50 40 70 70 90
arraymode = 10 20 30 40 20 70 10 50 40 70 70 90
arraymode = 10 20 30 40 20 10 70 50 40 70 70 90
arraymode = 10 20 30 40 20 10 50 70 40 70 70 90
arraymode = 10 20 30 40 20 10 50 40 70 70 70 90
arraymode = 10 20 30 20 40 10 50 40 70 70 70 90
arraymode = 10 20 30 20 10 40 50 40 70 70 70 90
arraymode = 10 20 30 20 10 40 40 50 70 70 70 90
arraymode = 10 20 20 30 10 40 40 50 70 70 70 90
arraymode = 10 20 20 10 30 40 40 50 70 70 70 90
arraymode = 10 20 10 20 30 40 40 50 70 70 70 90
arraymode = 10 10 20 20 30 40 40 50 70 70 70 90
配列要素中の最頻値　→　70

*/

************************************************
　猫の回転
************************************************
【課題314】arrayKaiten4.java			

String型の2次元配列in_arrayのデータを右回りに回転させる。

【ヒント】以下のソースプログラムを参照すること。【省略】部分を補いなさい。

		final int N = 7;													/*N行N列の配列*/
		String[][] in_array={
			{"　","　","■","　","■","　","　"},		/*処理前の配列*/
			{"　","　","◎","●","◎","　","　"},
			{"　","■","■","◇","■","■","　"},
			{"　","　","■","■","■","　","　"},
			{"　","　","■","■","■","　","■"},
			{"　","　","■","■","■","　","■"},
			{"　","■","■","×","■","■","　"},};
	
		//out側の配列定義
		String[][] out_array = new String [N][N];		
		BufferedReader br = 
			new BufferedReader(new InputStreamReader(System.in));

		
		/*in_array[][]を表示する*/				 
		System.out.print("msg:僕が右回転するよ。\n");
		for(int i = 0; i < N; i++){
			for(int j = 0; j < N; j++){
				System.out.print(in_array[i][j]);
			}
			System.out.print("\n");
		}
		
		//回転数の入力
		System.out.print("msg: 回転数を入力してください。　input > " );
		int kai_su = Integer.parseInt(br.readLine());
		

		for( int kai = 1; kai <= kai_su; kai++){
			/*90度右回転処理を行う*/				 
			for(int i = 0; i < N; i++){
				for(int j = 0; j < N; j++){
					/*９０度右回転*/	
					out_array[j][N-1-i] = in_array[【省略１】][【省略２】];
				}
			}
			
			//回転処理結果を表示する。
			for(int i = 0; i < N; i++){
				for(int j = 0; j < N; j++){
					System.out.print( out_array[i][j] ) ;
				}
				System.out.println();
			}
			System.out.println("msg: 90度、右回転（" + kai + "回、目がまわったにゃ～。）");
			
			//回転処理結果をin_arrayに反映する。
			for(int i = 0; i < N; i++){
				for(int j = 0; j < N; j++){
					【省略３】;
				}
			}
		}
	}
}
/*
(実行例)
msg:僕が右回転するよ。
　　■　■　　
　　◎●◎　　
　■■◇■■　
　　■■■　　
　　■■■　■
　　■■■　■
　■■×■■　
msg: 回転数を入力してください。　input > 5
　　　　　　　
■　　　■　　
■■■■■◎■
×■■■◇●　
■■■■■◎■
■　　　■　　
　■■　　　　
msg: 90度、右回転（1回、目がまわったにゃ～。）
　■■×■■　
■　■■■　　
■　■■■　　
　　■■■　　
　■■◇■■　
　　◎●◎　　
　　■　■　　
msg: 90度、右回転（2回、目がまわったにゃ～。）
　　　　■■　
　　■　　　■
■◎■■■■■
　●◇■■■×
■◎■■■■■
　　■　　　■
　　　　　　　
msg: 90度、右回転（3回、目がまわったにゃ～。）
　　■　■　　
　　◎●◎　　
　■■◇■■　
　　■■■　　
　　■■■　■
　　■■■　■
　■■×■■　
msg: 90度、右回転（4回、目がまわったにゃ～。）
　　　　　　　
■　　　■　　
■■■■■◎■
×■■■◇●　
■■■■■◎■
■　　　■　　
　■■　　　　
msg: 90度、右回転（5回、目がまわったにゃ～。）
*/

************************************************
　スプレッドシートを作成する。
************************************************
【課題315】spredsheet2.java			

簡易的なスプレッドシートを作成し、関数を実行してみる。

【ヒント】以下のソースプログラムを参照すること。【省略】部分を補いなさい。



		//列行の大きさを定義する。10ならJまでが表示される。
		System.out.print("msg:表の大きさを指定してください。　input(1-10) > ");
		int size = Integer.parseInt(br.readLine());

		//列の名前
		char[] retu = {'A','B','C','D','E','F','G','H','I','J','K','L',
					'M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z'};
		
		//配列array2[size][size]を数値で初期化する。
		int[][] array2 = new int[size][size];

		//インスタンスの作成	
		Retuhenkan re = new Retuhenkan();		//列文字を数字に変換
		Hairetusyori hi = new Hairetusyori();		//範囲の合計を求める
		
		//表計算のシートを用意する。
		System.out.println("msg:表計算の処理を行います。");
		System.out.print("\t");
		for( int j = 0; j < size; j++){
			System.out.print(retu[j] + "\t");
		}
		System.out.println();
		
		System.out.print("\t");
		for( int j = 0; j < size; j++){
			System.out.print("--------");
		}
		System.out.println();
		
		
		for( int i = 0; i < size; i++){
			System.out.print( i + "\t");
			for( int j = 0; j < size; j++){
				
				//各セルに入力する値は0～99とする。
				int hitnumber = (int)(Math.random() * 100);

				//例)sumの場合、計算しやすいように array2[i][j] = hitnumber/10;とするなど。
				array2[i][j] = hitnumber;
				System.out.print(array2[i][j] + "\t");
			}
			System.out.println("");
		}
		System.out.println("");
				
		
		//範囲列の入力		
		System.out.print("msg:開始範囲from(列)を入力してください input (A,B,C,D,E,F) > ");
		char from_retu_c = br.readLine().charAt(0);
		int from_retu = re.henkan( from_retu_c, retu );

		//範囲行の入力		
		System.out.print("msg:開始範囲from(行)を入力してください input (0,1,2,3,4,5) > ");
		int from_gyo = Integer.parseInt(br.readLine());
		
		//範囲列の入力		
		System.out.print("msg:終了範囲to(列)を入力してください input (A,B,C,D,E,F) > ");
		char to_retu_c = br.readLine().charAt(0);
		int to_retu = re.henkan( to_retu_c, retu );
		
		//範囲行の入力		
		System.out.print("msg:終了範囲to(行)を入力してください input (0,1,2,3,4,5) > ");
		int to_gyo = Integer.parseInt(br.readLine());
		
		//計算の実施、結果を関数毎に表示する。
		System.out.println();
		System.out.println("msg:関数を利用して求めた結果です。 ");

		System.out.print( "合計値：sum(" );
		System.out.print( from_retu_c + " " + from_gyo + "：" + to_retu_c + " " +  to_gyo + ")"  );
		int sum = hi.sum(from_gyo, from_retu, to_gyo, to_retu, array2);
		System.out.println(" = " + sum);


		System.out.print( "最大値：max(" );
		System.out.print( from_retu_c + " " + from_gyo + "：" + to_retu_c + " " +  to_gyo + ")"  );
		int max = hi.max(from_gyo, from_retu, to_gyo, to_retu, array2);
		System.out.println(" = " + max);


		System.out.print( "最小値：min(" );
		System.out.print( from_retu_c + " " + from_gyo + "：" + to_retu_c + " " +  to_gyo + ")"  );
		int min = hi.min(from_gyo, from_retu, to_gyo, to_retu, array2);
		System.out.println(" = " + min);


		System.out.print( "平均値：ave(" );
		System.out.print( from_retu_c + " " + from_gyo + "：" + to_retu_c + " " +  to_gyo + ")"  );
		int ave = hi.ave(from_gyo, from_retu, to_gyo, to_retu, array2);
		System.out.println(" = " + ave);
			
	}	
}

//渡された文字を判定して添字Noを返却	
class  Retuhenkan{
	public int henkan(char chr, char[] retu9){
		int kekka = 0; 
		for( int j = 0; j < retu9.length; j++){
			if( chr == retu9[j] ){
				kekka = j;
			}
		}
		return kekka;
	}
}	

class Hairetusyori{

	//渡された開始行、開始列、終了行、終了列の範囲で合計を取り、返却する。
	public int sum(int from_gyo, int from_retu, int to_gyo, int to_retu, int[][]array9){
		int kekka = 0;	
		
		for( int i = from_gyo; i <= to_gyo; i++){
			for( int j = from_retu; j <= to_retu; j++){
				  【省略１】;
			}
		}
		return kekka; 
	}
	
	//渡された開始行、開始列、終了行、終了列の範囲で最大値を見つけ返却する。
	public int max(int from_gyo, int from_retu, int to_gyo, int to_retu, int[][]array9){
		int kekka = array9[from_gyo][from_retu];	
		for( int i = from_gyo; i <= to_gyo; i++){
			for( int j = from_retu; j <= to_retu; j++){
				if( array9[i][j] > kekka){
					kekka = array9[i][j];
				}
			}
		}
		return kekka; 
	}

	
	//渡された開始行、開始列、終了行、終了列の範囲で最小値を見つけ返却する。
	public int min(int from_gyo, int from_retu, int to_gyo, int to_retu, int[][]array9){
		int kekka = array9[from_gyo][from_retu];	
		for( int i = from_gyo; i <= to_gyo; i++){
			for( int j = from_retu; j <= to_retu; j++){
				if( array9[i][j] < kekka){
					【省略２】;
				}
			}
		}
		return kekka; 
	}


	//渡された開始行、開始列、終了行、終了列の範囲で平均値を計算し返却する。
	public int ave(int from_gyo, int from_retu, int to_gyo, int to_retu, int[][]array9){
		int kekka = 0;	
		for( int i = from_gyo; i <= to_gyo; i++){
			for( int j = from_retu; j <= to_retu; j++){
					kekka += array9[i][j];
			}
		}
		kekka = kekka / ((to_gyo - from_gyo + 1)*(to_retu - from_retu + 1));
		return kekka; 
	}
}


/*
（実行例１）
msg:表の大きさを指定してください。　input(1-10) > 3
msg:表計算の処理を行います。
        A       B       C
        ------------------------
0       24      7       88
1       7       94      71
2       58      54      42

msg:開始範囲from(列)を入力してください input (A,B,C,D,E,F) > A
msg:開始範囲from(行)を入力してください input (0,1,2,3,4,5) > 0
msg:終了範囲to(列)を入力してください input (A,B,C,D,E,F) > C
msg:終了範囲to(行)を入力してください input (0,1,2,3,4,5) > 2

msg:関数を利用して求めた結果です。
合計値：sum(A 0：C 2) = 445
最大値：max(A 0：C 2) = 94
最小値：min(A 0：C 2) = 7
平均値：ave(A 0：C 2) = 49

（実行例２）

msg:表の大きさを指定してください。　input(1-10) > 10
msg:表計算の処理を行います。
        A       B       C       D       E       F       G       H       I       J
        --------------------------------------------------------------------------------
0       93      17      59      31      44      75      21      56      8       56
1       81      6       55      34      24      51      87      95      57      53
2       16      81      43      92      20      76      78      99      47      72
3       64      45      53      37      75      18      53      64      20      27
4       98      43      75      62      24      50      81      12      64      52
5       9       8       13      95      76      37      89      41      90      97
6       47      9       32      35      34      20      36      96      74      80
7       44      98      58      74      17      93      45      57      46      33
8       72      34      22      11      85      50      18      70      64      63
9       95      11      8       94      60      40      24      99      95      99

msg:開始範囲from(列)を入力してください input (A,B,C,D,E,F) > A
msg:開始範囲from(行)を入力してください input (0,1,2,3,4,5) > 0
msg:終了範囲to(列)を入力してください input (A,B,C,D,E,F) > B
msg:終了範囲to(行)を入力してください input (0,1,2,3,4,5) > 9

msg:関数を利用して求めた結果です。
合計値：sum(A 0：B 9) = 971
最大値：max(A 0：B 9) = 98
最小値：min(A 0：B 9) = 6
平均値：ave(A 0：B 9) = 48

（実行例３）
msg:表の大きさを指定してください。　input(1-10) > 3
msg:表計算の処理を行います。
        A       B       C
        ------------------------
0       60      25      88
1       79      29      33
2       85      98      2

msg:開始範囲from(列)を入力してください input (A,B,C,D,E,F) > A
msg:開始範囲from(行)を入力してください input (0,1,2,3,4,5) > 0
msg:終了範囲to(列)を入力してください input (A,B,C,D,E,F) > C
msg:終了範囲to(行)を入力してください input (0,1,2,3,4,5) > 2

msg:関数を利用して求めた結果です。
合計値：sum(A 0：C 2) = 499
最大値：max(A 0：C 2) = 98
最小値：min(A 0：C 2) = 2
平均値：ave(A 0：C 2) = 55
*/